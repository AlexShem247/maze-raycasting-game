package com.raycaster.game;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import javax.imageio.ImageIO;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

enum SHAPE_TYPE {RECTANGLE, CIRCLE, ENEMY1, ENEMY2, COIN}

abstract class Shape {

  int x, y;

  abstract int getCentreX();

  abstract int getCentreY();

  public static final String[] LOC_TYPES = {"topLeft", "top", "topRight",
      "left", "centre", "right",
      "bottomLeft", "bottom", "bottomRight"};

  public String getLocation(int imgWidth, int imgHeight) {
    int centreX = getCentreX(), centreY = getCentreY();
    String xLoc = "", yLoc = "";

    if (centreX < imgWidth / 3) {
      xLoc = "Left";
    } else if (centreX > imgWidth * 2 / 3) {
      xLoc = "Right";
    }

    if (centreY < imgHeight / 3) {
      yLoc = "top";
    } else if (centreY > imgHeight * 2 / 3) {
      yLoc = "bottom";
    } else {
      xLoc = xLoc.toLowerCase();
    }

    String name = yLoc + xLoc;
    return name.equals("") ? "centre" : name;
  }
}


class Rectangle extends Shape {

  int width, height;

  public Rectangle(int x, int y, int width, int height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }

  @Override
  public String toString() {
    return "new RectBorder(" + x + ", " + y + ", " + width + ", " + height + ")";
  }

  @Override
  int getCentreX() {
    return x + width / 2;
  }

  @Override
  int getCentreY() {
    return y + height / 2;
  }
}

class Circle extends Shape {

  int radius;

  public Circle(int x, int y, int radius) {
    this.x = x;
    this.y = y;
    this.radius = radius;
  }

  @Override
  public String toString() {
    return "new CircleBorder(" + x + ", " + y + ", " + radius + ")";
  }

  @Override
  int getCentreX() {
    return x;
  }

  @Override
  int getCentreY() {
    return y;
  }
}

class EnemyShape extends Circle {

  String enemyType;

  public EnemyShape(int x, int y, String enemyType) {
    super(x, y, Objects.equals(enemyType, "Coin") ? 3 : 5);
    this.enemyType = enemyType;
  }

  @Override
  public String toString() {
    return "new " + enemyType + "(screen, " + x + ", " + y + ")";
  }
}

class BorderGenerator {

  private int imgWidth;
  private int imgHeight;
  private final List<Rectangle> recs;

  private final List<Circle> circles;
  private final List<EnemyShape> enemies;
  private final List<EnemyShape> items;
  private final int COLOR_THRESHOLD = 40;

  public boolean[][] generateBooleanArrayFromImage(String imagePath, SHAPE_TYPE type) {
    try {
      // Load the image using ImageIO
      BufferedImage image = ImageIO.read(new File(imagePath));

      // Get the width and height of the image
      imgWidth = image.getWidth();
      imgHeight = image.getHeight();

      // Create a 2D boolean array to store the pixel data
      boolean[][] pixelData = new boolean[imgHeight][imgWidth];

      // Loop through each pixel and check if it's solid or transparent
      for (int y = 0; y < imgHeight; y++) {
        for (int x = 0; x < imgWidth; x++) {
          int pixel = image.getRGB(x, y);

          // Extract RGB components
          int alpha = (pixel >> 24) & 0xFF;
          int red = (pixel >> 16) & 0xFF;
          int green = (pixel >> 8) & 0xFF;
          int blue = pixel & 0xFF;

          switch (type) {

            case RECTANGLE:
              pixelData[y][x] =
                  equals(red, 0) && equals(green, 0) && equals(blue, 0) && alpha != 0;
              break;
            case CIRCLE:
              pixelData[y][x] =
                  equals(red, 88) && equals(green, 88) && equals(blue, 88) && alpha != 0;
              break;
            case ENEMY1:
              pixelData[y][x] =
                  equals(red, 255) && equals(green, 0) && equals(blue, 0) && alpha != 0;
              break;
            case ENEMY2:
              pixelData[y][x] =
                  equals(red, 255) && equals(green, 255) && equals(blue, 0) && alpha != 0;
              break;
            case COIN:
              pixelData[y][x] =
                  equals(red, 255) && equals(green, 127) && equals(blue, 39) && alpha != 0;
              break;
          }
        }
      }

      return pixelData;
    } catch (IOException e) {
      e.printStackTrace();
    }

    return null;
  }

  private boolean equals(int val1, int val2) {
    return Math.abs(val1 - val2) < COLOR_THRESHOLD;
  }

  public BorderGenerator(String imagePath) {
    // 1. Process Image
    boolean[][] recImg = generateBooleanArrayFromImage(imagePath, SHAPE_TYPE.RECTANGLE);
    boolean[][] cirImg = generateBooleanArrayFromImage(imagePath, SHAPE_TYPE.CIRCLE);
    boolean[][] em1Img = generateBooleanArrayFromImage(imagePath, SHAPE_TYPE.ENEMY1);
    boolean[][] em2Img = generateBooleanArrayFromImage(imagePath, SHAPE_TYPE.ENEMY2);
    boolean[][] it1Img = generateBooleanArrayFromImage(imagePath, SHAPE_TYPE.COIN);

    // 2. Locate Rectangles
    recs = locateRectangles(recImg);

    // 3. Locate Circles
    circles = locateCircles(cirImg);

    // 4. Locate Enemies
    enemies = new ArrayList<>();
    enemies.addAll(locateEnemies(em1Img, "Enemy1"));
    enemies.addAll(locateEnemies(em2Img, "Enemy2"));

    // 5. Locate Items
    items = new ArrayList<>();
    items.addAll(locateEnemies(it1Img, "Coin"));
  }

  private List<EnemyShape> locateEnemies(boolean[][] img, String enemyName) {
    List<EnemyShape> enemies = new ArrayList<>();
    for (int j = 0; j < imgHeight; j++) {
      for (int i = 0; i < imgWidth; i++) {
        if (img[j][i]) {
          // Generate circle containing point (i, j)
          // 1. Calc. centre x value
          int topSliceWidth = 1;
          while (i + topSliceWidth < imgWidth && img[j][i + topSliceWidth]) {
            topSliceWidth++;
          }
          int cX = i + topSliceWidth / 2;
          // 2. Calc. centre y value
          int height = 1;
          while (j + height < imgHeight && img[j + height][cX]) {
            height++;
          }
          int cY = j + height / 2;

          // 3. Calc. width
          int width = 1;
          while (cX + width < imgWidth && img[cY][cX + width]) {
            width++;
          }
          width *= 2;

          // 4. Add Circle to list
          if (height + width > 4) {
            enemies.add(new EnemyShape(cX, cY, enemyName));
          }

          // 5. Set values in img that are covered by this circle to false
          for (int y = cY - height / 2 - 1; y < cY + height / 2 + 1; y++) {
            for (int x = cX - width / 2 - 1; x < cX + width / 2 + 1; x++) {
              img[y][x] = false;
            }
          }
        }
      }
    }
    return enemies;
  }

  private List<Circle> locateCircles(boolean[][] img) {
    List<Circle> circles = new ArrayList<>();
    for (int j = 0; j < imgHeight; j++) {
      for (int i = 0; i < imgWidth; i++) {
        if (img[j][i]) {
          // Generate circle containing point (i, j)
          // 1. Calc. centre x value
          int topSliceWidth = 1;
          while (i + topSliceWidth < imgWidth && img[j][i + topSliceWidth]) {
            topSliceWidth++;
          }
          int cX = i + topSliceWidth / 2;
          // 2. Calc. centre y value
          int height = 1;
          while (j + height < imgHeight && img[j + height][cX]) {
            height++;
          }
          int cY = j + height / 2;

          // 3. Calc. width
          int width = 1;
          while (cX + width < imgWidth && img[cY][cX + width]) {
            width++;
          }
          width *= 2;

          // 4. Add Circle to list
          if (height + width > 4) {
            circles.add(new Circle(cX, cY, Math.min(width / 2, height / 2)));
          }

          // 5. Set values in img that are covered by this circle to false
          for (int y = cY - height / 2 - 1; y < cY + height / 2 + 1; y++) {
            for (int x = cX - width / 2 - 1; x < cX + width / 2 + 1; x++) {
              img[y][x] = false;
            }
          }
        }
      }
    }

    return circles;
  }

  public List<Rectangle> getRectangles() {
    return recs;
  }

  public List<Circle> getCircles() {
    return circles;
  }

  public int getWidth() {
    return imgWidth;
  }

  public int getHeight() {
    return imgHeight;
  }

  public void generateFile(String filePath) {
    // Generate content
    StringBuilder text = new StringBuilder("// Create Shapes for Game Map\n");
    List<String> shapeList = new ArrayList<>();
    for (String locType : Shape.LOC_TYPES) {
      int shapeNo = 1;
      for (Rectangle rec : recs) {
        if (rec.getLocation(imgWidth, imgHeight).equals(locType)) {
          text.append("RectBorder ");
          String shapeName =
              rec.getLocation(imgWidth, imgHeight) + "Rect" + shapeNo;
          text.append(shapeName);
          shapeList.add(shapeName);
          text.append(" = ");
          text.append(rec);
          text.append(";\n");
          shapeNo++;
        }
      }
      if (shapeNo > 1) {
        // If a shape has been written
        text.append("\n");
      }
    }

    for (String locType : Shape.LOC_TYPES) {
      int shapeNo = 1;
      for (Circle cir : circles) {
        if (cir.getLocation(imgWidth, imgHeight).equals(locType)) {
          text.append("CircleBorder ");
          String shapeName = cir.getLocation(imgWidth, imgHeight) + "Circle" + shapeNo;
          text.append(shapeName);
          shapeList.add(shapeName);
          text.append(" = ");
          text.append(cir);
          text.append(";\n");
          shapeNo++;
        }
      }
      if (shapeNo > 1) {
        // If a shape has been written
        text.append("\n");
      }
    }

    // Generate array
    text.append("shapes = new Border[]{");
    text.append(String.join(", ", shapeList));
    text.append("};\n\n    // Create Enemies\n");

    // Generate Enemies
    List<String> enemyList = new ArrayList<>();
    for (String locType : Shape.LOC_TYPES) {
      int shapeNo = 1;
      for (EnemyShape enemy : enemies) {
        if (enemy.getLocation(imgWidth, imgHeight).equals(locType)) {
          text.append(enemy.enemyType).append(" ");
          String shapeName =
              enemy.getLocation(imgWidth, imgHeight) + enemy.enemyType + shapeNo;
          text.append(shapeName);
          enemyList.add(shapeName);
          text.append(" = ");
          text.append(enemy);
          text.append(";\n");
          shapeNo++;
        }
      }
      if (shapeNo > 1) {
        // If a shape has been written
        text.append("\n");
      }
    }

    text.append("enemies = new Enemy[]{");
    text.append(String.join(", ", enemyList));
    text.append("};\n\n    // Create Items\n");

    // Generate Items
    List<String> itemList = new ArrayList<>();
    for (String locType : Shape.LOC_TYPES) {
      int shapeNo = 1;
      for (EnemyShape item : items) {
        if (item.getLocation(imgWidth, imgHeight).equals(locType)) {
          text.append(item.enemyType).append(" ");
          String shapeName =
              item.getLocation(imgWidth, imgHeight) + item.enemyType + shapeNo;
          text.append(shapeName);
          itemList.add(shapeName);
          text.append(" = ");
          text.append(item);
          text.append(";\n");
          shapeNo++;
        }
      }
      if (shapeNo > 1) {
        // If a shape has been written
        text.append("\n");
      }
    }

    text.append("items = new Item[]{");
    text.append(String.join(", ", itemList));
    text.append("};");

    try (FileWriter fileWriter = new FileWriter(filePath)) {
      fileWriter.write(text.toString());
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  private List<Rectangle> locateRectangles(boolean[][] img) {
    List<Rectangle> recs = new ArrayList<>();
    for (int j = 0; j < imgHeight; j++) {
      for (int i = 0; i < imgWidth; i++) {
        if (img[j][i]) {
          // Generate rectangle starting from point (i, j)
          // 1. Calc. width of rectangle
          int width = 1;
          while (i + width < imgWidth && img[j][i + width]) {
            width++;
          }
          // 2. Calc. height of rectangle
          int height = 1;
          while (j + height < imgHeight && allTrue(
              Arrays.copyOfRange(img[j + height], i, i + width))) {
            height++;
          }

          // 3. Add Rectangle to list
          recs.add(new Rectangle(i, j, width, height));

          // 4. Set values in img that are covered by this rectangle to false
          for (int y = j; y < j + height; y++) {
            for (int x = i; x < i + width; x++) {
              img[y][x] = false;
            }
          }
        }
      }
    }
    return recs;
  }

  public static boolean allTrue(boolean[] boolArray) {
    for (boolean value : boolArray) {
      if (!value) {
        return false;
      }
    }
    return true;
  }

  public List<EnemyShape> getEnemies() {
    return enemies;
  }
  public List<EnemyShape> getItems() {
    return items;
  }
}


public class MapGenerator extends JComponent {

  private static List<Rectangle> recs;
  private static List<Circle> circles;
  private static List<EnemyShape> enemies;
  private static List<EnemyShape> items;

  @Override
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);

    // Set the color and draw the rectangles
    g.setColor(Color.BLACK);
    for (Rectangle rec : recs) {
      g.fillRect(rec.x, rec.y, rec.width, rec.height);
    }

    // Set the color and draw the circles
    g.setColor(Color.BLACK);
    for (Circle cir : circles) {
      g.fillOval(cir.x - cir.radius, cir.y - cir.radius, cir.radius * 2, cir.radius * 2);
    }

    // Set the color and draw the enemies
    for (EnemyShape enemy : enemies) {
      g.setColor(enemy.enemyType.equals("Enemy1") ? Color.RED : Color.YELLOW);
      g.fillOval(enemy.x - enemy.radius, enemy.y - enemy.radius, enemy.radius * 2,
          enemy.radius * 2);
    }

    // Set the color and draw the items
    for (EnemyShape item : items) {
      g.setColor(Color.ORANGE);
      g.fillOval(item.x - item.radius, item.y - item.radius, item.radius * 2,
          item.radius * 2);
    }
  }

  public static void main(String[] args) {
    BorderGenerator gen = new BorderGenerator("maze.png");
    gen.generateFile("map.txt");
    recs = gen.getRectangles();
    circles = gen.getCircles();
    enemies = gen.getEnemies();
    items = gen.getItems();
    SwingUtilities.invokeLater(() -> {
      JFrame frame = new JFrame("Game Map");
      frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      frame.setSize(gen.getWidth() + 50, gen.getHeight() + 50);

      // Create an instance of the custom component and add it to the frame
      MapGenerator mapDrawer = new MapGenerator();
      frame.add(mapDrawer);

      frame.setVisible(true);
    });
  }
}

